# C++ å¤šçº¿ç¨‹é¢è¯•é€ŸæŸ¥å¡ âš¡

## ğŸ¯ æœ€é«˜é¢‘é¢è¯•é¢˜ TOP 5

### 1. â­â­â­â­â­ `lock_guard` vs `unique_lock`

**ä¸€å¥è¯å›ç­”ï¼š**

> `lock_guard` ç®€å•è‡ªåŠ¨ï¼Œ`unique_lock` çµæ´»å¼ºå¤§ï¼Œæ¡ä»¶å˜é‡å¿…é¡»ç”¨ `unique_lock`

**è¯¦ç»†å¯¹æ¯”ï¼š**

```cpp
// lock_guard - ç®€å•
{
    std::lock_guard<std::mutex> lock(mtx);
    // è‡ªåŠ¨åŠ é”ï¼Œè‡ªåŠ¨è§£é”
}

// unique_lock - çµæ´»
{
    std::unique_lock<std::mutex> lock(mtx);
    lock.unlock();  // å¯ä»¥æ‰‹åŠ¨è§£é”
    // åšä¸éœ€è¦é”çš„å·¥ä½œ
    lock.lock();    // å¯ä»¥é‡æ–°åŠ é”
}

// æ¡ä»¶å˜é‡ï¼ˆå¿…é¡» unique_lockï¼‰
std::unique_lock<std::mutex> lock(mtx);
cv.wait(lock);  // wait éœ€è¦èƒ½ unlock
```

| ç‰¹æ€§     | lock_guard | unique_lock |
| -------- | ---------- | ----------- |
| æ‰‹åŠ¨æ§åˆ¶ | âŒ         | âœ…          |
| æ¡ä»¶å˜é‡ | âŒ         | âœ… (å¿…é¡»)   |
| æ€§èƒ½     | å¿«         | ç¨æ…¢        |

---

### 2. â­â­â­â­â­ ä»€ä¹ˆæ˜¯æ­»é”ï¼Ÿå¦‚ä½•é¿å…ï¼Ÿ

**å®šä¹‰ï¼š** å¤šä¸ªçº¿ç¨‹äº’ç›¸ç­‰å¾…å¯¹æ–¹é‡Šæ”¾èµ„æº

**ç»å…¸åœºæ™¯ï¼š**

```cpp
// çº¿ç¨‹1: å…ˆé”Aï¼Œå†é”B
mtx_a.lock();
mtx_b.lock();

// çº¿ç¨‹2: å…ˆé”Bï¼Œå†é”A â†’ æ­»é”ï¼
mtx_b.lock();
mtx_a.lock();
```

**é¿å…æ–¹æ³•ï¼š**

1. **å›ºå®šåŠ é”é¡ºåº**ï¼ˆæœ€å¸¸ç”¨ï¼‰
2. ä½¿ç”¨ `std::scoped_lock` (C++17)
3. é¿å…åµŒå¥—é”
4. ä½¿ç”¨è¶…æ—¶æœºåˆ¶

---

### 3. â­â­â­â­ æ¡ä»¶å˜é‡çš„å·¥ä½œåŸç†

**æ ¸å¿ƒï¼š** ç­‰å¾…æŸä¸ªæ¡ä»¶æˆç«‹ï¼ŒæœŸé—´é‡Šæ”¾é”å¹¶ä¼‘çœ 

```cpp
std::unique_lock<std::mutex> lock(mtx);
cv.wait(lock, []{ return condition; });

// ç­‰ä»·äºï¼š
while (!condition) {
    // 1. é‡Šæ”¾é”
    // 2. çº¿ç¨‹ä¼‘çœ ï¼ˆä¸å CPUï¼‰
    // 3. ç­‰å¾… notify
    // 4. è¢«å”¤é†’åé‡æ–°è·å–é”
}
```

**ä¸ºä»€ä¹ˆå¿…é¡»ç”¨ unique_lockï¼Ÿ**

- å› ä¸º wait éœ€è¦èƒ½å¤Ÿé‡Šæ”¾å’Œé‡æ–°è·å–é”
- lock_guard ä¸æ”¯æŒ unlock

---

### 4. â­â­â­â­ æ•°æ®ç«äº‰æ˜¯ä»€ä¹ˆï¼Ÿ

**å®šä¹‰ï¼š** å¤šçº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€æ•°æ®ï¼Œè‡³å°‘ä¸€ä¸ªå†™ï¼Œä¸”æ— åŒæ­¥

```cpp
int counter = 0;  // å…±äº«å˜é‡

void increment() {
    counter++;  // æ•°æ®ç«äº‰ï¼(è¯»-æ”¹-å†™ä¸æ˜¯åŸå­çš„)
}
```

**è§£å†³æ–¹æ¡ˆï¼š**

```cpp
// æ–¹æ¡ˆ1: mutex
std::mutex mtx;
{
    std::lock_guard<std::mutex> lock(mtx);
    counter++;
}

// æ–¹æ¡ˆ2: atomic
std::atomic<int> counter(0);
counter++;  // åŸå­æ“ä½œ
```

---

### 5. â­â­â­ `notify_one()` vs `notify_all()`

```cpp
cv.notify_one();   // å”¤é†’ä¸€ä¸ªç­‰å¾…çš„çº¿ç¨‹
cv.notify_all();   // å”¤é†’æ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹
```

**ä½¿ç”¨åœºæ™¯ï¼š**

- **notify_one**: å•æ¶ˆè´¹è€…æ¨¡å¼ï¼ˆæ•ˆç‡é«˜ï¼‰
- **notify_all**: å¤šæ¶ˆè´¹è€…éƒ½éœ€è¦å“åº”ï¼ˆå¦‚å¹¿æ’­ï¼‰

---

## ğŸ”‘ å…³é”®æ¦‚å¿µé€Ÿè®°

### RAIIï¼ˆResource Acquisition Is Initializationï¼‰

```cpp
// æ„é€ æ—¶è·å–èµ„æºï¼Œææ„æ—¶è‡ªåŠ¨é‡Šæ”¾
{
    std::lock_guard<std::mutex> lock(mtx);
    // ä¸´ç•ŒåŒº
}  // è‡ªåŠ¨è§£é”ï¼Œå³ä½¿æŠ›å¼‚å¸¸ä¹Ÿå®‰å…¨
```

### ä¸´ç•ŒåŒºï¼ˆCritical Sectionï¼‰

```cpp
// éœ€è¦äº’æ–¥è®¿é—®çš„ä»£ç æ®µ
std::lock_guard<std::mutex> lock(mtx);
shared_data++;  // ä¸´ç•ŒåŒº
```

### åŸå­æ“ä½œï¼ˆAtomic Operationï¼‰

```cpp
std::atomic<int> counter(0);
counter++;  // å•ä¸ªä¸å¯åˆ†å‰²çš„æ“ä½œ
```

---

## ğŸ“Š å¸¸ç”¨ç±»é€ŸæŸ¥è¡¨

| ç±»                        | ä½œç”¨     | ä½¿ç”¨åœºæ™¯          |
| ------------------------- | -------- | ----------------- |
| `std::thread`             | åˆ›å»ºçº¿ç¨‹ | å¹¶å‘æ‰§è¡Œ          |
| `std::mutex`              | äº’æ–¥é”   | ä¿æŠ¤å…±äº«æ•°æ®      |
| `std::lock_guard`         | è‡ªåŠ¨é”   | ç®€å•ä¸´ç•ŒåŒº        |
| `std::unique_lock`        | çµæ´»é”   | æ¡ä»¶å˜é‡/å¤æ‚åœºæ™¯ |
| `std::condition_variable` | æ¡ä»¶å˜é‡ | çº¿ç¨‹é€šä¿¡          |
| `std::atomic`             | åŸå­ç±»å‹ | æ— é”ç¼–ç¨‹          |

---

## ğŸ’¡ é¢è¯•å›ç­”æ¨¡æ¿

### Q: "ä½ åœ¨é¡¹ç›®ä¸­å¦‚ä½•ä½¿ç”¨å¤šçº¿ç¨‹ï¼Ÿ"

**å›ç­”æ¨¡æ¿ï¼š**

> "åœ¨æˆ‘çš„ TimerManager é¡¹ç›®ä¸­ï¼Œæˆ‘ä½¿ç”¨äº†å¤šçº¿ç¨‹æ¥å®ç°å®šæ—¶å™¨ç®¡ç†ï¼š
>
> 1. **çº¿ç¨‹ç®¡ç†**: åˆ›å»ºäº†ä¸€ä¸ªå·¥ä½œçº¿ç¨‹ç”¨äºæ£€æŸ¥å®šæ—¶å™¨åˆ°æœŸ
> 2. **æ•°æ®ä¿æŠ¤**: ç”¨ `std::mutex` ä¿æŠ¤å®šæ—¶å™¨åˆ—è¡¨è¿™ä¸ªå…±äº«èµ„æº
> 3. **é”ç®¡ç†**: ç®€å•åœºæ™¯ç”¨ `lock_guard`ï¼Œé…åˆæ¡ä»¶å˜é‡ç”¨ `unique_lock`
> 4. **çº¿ç¨‹é€šä¿¡**: ç”¨ `condition_variable` å®ç°æ™ºèƒ½ç­‰å¾…ï¼Œé¿å…è½®è¯¢
> 5. **åŸå­æ“ä½œ**: ç”¨ `std::atomic<bool>` ä½œä¸ºè¿è¡Œæ ‡å¿—
>
> è¿™æ ·è®¾è®¡çš„å¥½å¤„æ˜¯é™ä½äº† CPU å ç”¨ï¼Œä»å›ºå®š 100ms è½®è¯¢ä¼˜åŒ–åˆ°æŒ‰éœ€å”¤é†’ï¼Œå”¤é†’æ¬¡æ•°å‡å°‘äº† 90%ã€‚"

---

## ğŸš¨ å¸¸è§é™·é˜±

### 1. å¿˜è®° join/detach

```cpp
std::thread t(work);
// âŒ çº¿ç¨‹å¯¹è±¡ææ„å‰å¿…é¡» join æˆ– detach
// å¦åˆ™ std::terminate()
```

### 2. é”å†…è°ƒç”¨å›è°ƒ

```cpp
{
    std::lock_guard<std::mutex> lock(mtx);
    callback();  // âŒ å›è°ƒå¯èƒ½å¾ˆæ…¢æˆ–å†æ¬¡åŠ é”ï¼ˆæ­»é”ï¼‰
}
// âœ… åº”åœ¨é”å¤–è°ƒç”¨
```

### 3. æ¡ä»¶å˜é‡è™šå‡å”¤é†’

```cpp
// âŒ é”™è¯¯
cv.wait(lock);
if (condition) { ... }

// âœ… æ­£ç¡®
cv.wait(lock, []{ return condition; });
// æˆ–
while (!condition) {
    cv.wait(lock);
}
```

---

## ğŸ“ å­¦ä¹ ä¼˜å…ˆçº§

### ç¬¬ä¸€ä¼˜å…ˆçº§ï¼ˆå¿…é¡»æŒæ¡ï¼‰

- [x] `std::thread` åŸºæœ¬ç”¨æ³•
- [x] `std::mutex` + `std::lock_guard`
- [x] `std::unique_lock` + `std::condition_variable`
- [x] æ•°æ®ç«äº‰å’Œæ­»é”æ¦‚å¿µ

### ç¬¬äºŒä¼˜å…ˆçº§ï¼ˆé‡è¦ï¼‰

- [ ] `std::atomic` åŸºæœ¬ç”¨æ³•
- [ ] `notify_one()` vs `notify_all()`
- [ ] è™šå‡å”¤é†’å¤„ç†
- [ ] æ­»é”é¿å…ç­–ç•¥

### ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼ˆè¿›é˜¶ï¼‰

- [ ] `std::shared_mutex` (è¯»å†™é”)
- [ ] `std::scoped_lock` (C++17)
- [ ] `std::jthread` (C++20)
- [ ] Memory Order

---

## ğŸ“ å®æˆ˜æ£€æŸ¥æ¸…å•

è¿è¡Œé¡¹ç›®å‰ç¡®è®¤ï¼š

- [ ] æ‰€æœ‰ `std::thread` éƒ½æœ‰ join/detach
- [ ] å…±äº«æ•°æ®éƒ½æœ‰é”ä¿æŠ¤
- [ ] æ¡ä»¶å˜é‡ä½¿ç”¨äº† `unique_lock`
- [ ] å›è°ƒåœ¨é”å¤–æ‰§è¡Œ
- [ ] æ²¡æœ‰åµŒå¥—é”æˆ–æŒ‰å›ºå®šé¡ºåºåŠ é”

---

## ğŸ”— å¿«é€Ÿå‚è€ƒ

```cpp
// åˆ›å»ºçº¿ç¨‹
std::thread t(func, arg1, arg2);
t.join();

// ä¿æŠ¤æ•°æ®
std::mutex mtx;
std::lock_guard<std::mutex> lock(mtx);

// æ¡ä»¶ç­‰å¾…
std::unique_lock<std::mutex> lock(mtx);
cv.wait(lock, []{ return ready; });

// é€šçŸ¥
cv.notify_one();

// åŸå­æ“ä½œ
std::atomic<int> count(0);
count++;
```

---

**è®°ä½ï¼šå¤šçº¿ç¨‹çš„æ ¸å¿ƒæ˜¯åŒæ­¥å’Œé€šä¿¡ï¼** ğŸš€

**é¢è¯•æ—¶çš„é»„é‡‘æ³•åˆ™ï¼š**

1. å…ˆè¯´æ¦‚å¿µï¼ˆæ˜¯ä»€ä¹ˆï¼‰
2. å†è¯´åŒºåˆ«ï¼ˆä¸ºä»€ä¹ˆï¼‰
3. æœ€åä¸¾ä¾‹ï¼ˆé¡¹ç›®ä¸­æ€ä¹ˆç”¨ï¼‰
4. æåˆ° TimerManager é¡¹ç›®åŠ åˆ†ï¼
