# C++ 单例模式实现

单例模式（Singleton Pattern）确保一个类只有一个实例，并提供一个全局访问点。在 C++中，有多种实现方式，每种都有其优缺点。

## 1. 经典的懒汉式单例（线程不安全）

```cpp
class Singleton {
private:
    static Singleton* instance;

    // 私有构造函数，防止外部实例化
    Singleton() {
        std::cout << "Singleton instance created" << std::endl;
    }

    // 禁止拷贝构造和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

public:
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }

    void doSomething() {
        std::cout << "Singleton is doing something..." << std::endl;
    }

    // 可选：提供销毁方法
    static void destroyInstance() {
        delete instance;
        instance = nullptr;
    }
};

// 静态成员变量的定义
Singleton* Singleton::instance = nullptr;
```

**优点**：简单易懂，延迟初始化
**缺点**：线程不安全，在多线程环境下可能创建多个实例

## 2. 线程安全的懒汉式单例（双重检查锁定）

```cpp
#include <mutex>

class ThreadSafeSingleton {
private:
    static ThreadSafeSingleton* instance;
    static std::mutex mtx;

    ThreadSafeSingleton() {
        std::cout << "ThreadSafeSingleton instance created" << std::endl;
    }

    ThreadSafeSingleton(const ThreadSafeSingleton&) = delete;
    ThreadSafeSingleton& operator=(const ThreadSafeSingleton&) = delete;

public:
    static ThreadSafeSingleton* getInstance() {
        // 第一次检查，避免不必要的锁开销
        if (instance == nullptr) {
            std::lock_guard<std::mutex> lock(mtx);
            // 第二次检查，确保线程安全
            if (instance == nullptr) {
                instance = new ThreadSafeSingleton();
            }
        }
        return instance;
    }

    void doSomething() {
        std::cout << "ThreadSafeSingleton is doing something..." << std::endl;
    }

    static void destroyInstance() {
        std::lock_guard<std::mutex> lock(mtx);
        delete instance;
        instance = nullptr;
    }
};

// 静态成员变量的定义
ThreadSafeSingleton* ThreadSafeSingleton::instance = nullptr;
std::mutex ThreadSafeSingleton::mtx;
```

**优点**：线程安全，延迟初始化，性能较好
**缺点**：实现复杂，需要手动管理内存

## 3. Meyers 单例（推荐方式）

```cpp
class MeyersSingleton {
private:
    MeyersSingleton() {
        std::cout << "MeyersSingleton instance created" << std::endl;
    }

    MeyersSingleton(const MeyersSingleton&) = delete;
    MeyersSingleton& operator=(const MeyersSingleton&) = delete;

public:
    static MeyersSingleton& getInstance() {
        static MeyersSingleton instance; // C++11保证线程安全的静态局部变量
        return instance;
    }

    void doSomething() {
        std::cout << "MeyersSingleton is doing something..." << std::endl;
    }
};
```

**优点**：

- 线程安全（C++11 标准保证）
- 自动内存管理（析构时自动销毁）
- 延迟初始化
- 实现简洁

**缺点**：无法手动控制销毁时机

## 4. 饿汉式单例（预先初始化）

```cpp
class EagerSingleton {
private:
    static EagerSingleton instance;

    EagerSingleton() {
        std::cout << "EagerSingleton instance created" << std::endl;
    }

    EagerSingleton(const EagerSingleton&) = delete;
    EagerSingleton& operator=(const EagerSingleton&) = delete;

public:
    static EagerSingleton& getInstance() {
        return instance;
    }

    void doSomething() {
        std::cout << "EagerSingleton is doing something..." << std::endl;
    }
};

// 程序启动时就创建实例
EagerSingleton EagerSingleton::instance;
```

**优点**：线程安全，实现简单，不需要锁
**缺点**：不是延迟初始化，可能造成资源浪费

## 5. 模板化单例基类

```cpp
template<typename T>
class SingletonBase {
protected:
    SingletonBase() = default;
    virtual ~SingletonBase() = default;

    SingletonBase(const SingletonBase&) = delete;
    SingletonBase& operator=(const SingletonBase&) = delete;

public:
    static T& getInstance() {
        static T instance;
        return instance;
    }
};

// 使用示例
class DatabaseManager : public SingletonBase<DatabaseManager> {
private:
    friend class SingletonBase<DatabaseManager>; // 允许基类访问构造函数

    DatabaseManager() {
        std::cout << "DatabaseManager initialized" << std::endl;
    }

public:
    void connect() {
        std::cout << "Database connected" << std::endl;
    }

    void query(const std::string& sql) {
        std::cout << "Executing query: " << sql << std::endl;
    }
};
```

## 6. 完整的使用示例

```cpp
#include <iostream>
#include <thread>
#include <vector>

// 测试函数
void testSingleton() {
    auto& singleton = MeyersSingleton::getInstance();
    singleton.doSomething();
}

int main() {
    std::cout << "=== 单例模式测试 ===" << std::endl;

    // 1. 基本使用
    auto& s1 = MeyersSingleton::getInstance();
    auto& s2 = MeyersSingleton::getInstance();

    std::cout << "s1 address: " << &s1 << std::endl;
    std::cout << "s2 address: " << &s2 << std::endl;
    std::cout << "Same instance: " << (&s1 == &s2) << std::endl;

    // 2. 多线程测试
    std::vector<std::thread> threads;
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(testSingleton);
    }

    for (auto& t : threads) {
        t.join();
    }

    // 3. 模板化单例使用
    auto& dbManager = DatabaseManager::getInstance();
    dbManager.connect();
    dbManager.query("SELECT * FROM users");

    return 0;
}
```

## 最佳实践建议

1. **推荐使用 Meyers 单例**：在大多数情况下，Meyers 单例是最好的选择，因为它简洁、线程安全且自动管理内存。

2. **避免使用指针版本**：除非有特殊需求，避免使用返回指针的版本，因为需要手动管理内存。

3. **考虑依赖注入**：在某些情况下，依赖注入可能比单例模式更合适，特别是在需要测试的场景中。

4. **注意销毁顺序**：如果单例之间有依赖关系，要注意析构顺序问题。

5. **避免过度使用**：单例模式虽然有用，但过度使用会导致代码耦合度高，难以测试。

## 注意事项

- 单例模式违反了单一职责原则
- 在单元测试中可能造成困难
- 隐藏了类之间的依赖关系
- 在多线程环境下需要特别注意线程安全
