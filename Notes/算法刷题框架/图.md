## 有向加权图（邻接表实现）

```cpp
// 有向加权图（邻接表实现） (English: Directed Weighted Graph using Adjacency List)
#include <gtest/gtest.h>

#include <iostream>
#include <vector>
#include <unordered_map>
#include <list>
#include <algorithm>
#include <climits>
#include <queue>
using namespace std;

// 边的结构体
struct Edge {
    int destination;
    int weight;

    Edge(int dest, int w) : destination(dest), weight(w) {}
};

// 有向加权图类
class DirectedWeightedGraph {
private:
    int numVertices;
    unordered_map<int, list<Edge>> adjList;

public:
    // 构造函数
    DirectedWeightedGraph(int vertices = 0) : numVertices(vertices) {}

    // 添加顶点
    void addVertex(int vertex) {
        if (adjList.find(vertex) == adjList.end()) {
            adjList[vertex] = list<Edge>();
            numVertices++;
        }
    }

    // 添加边 TODO: what if there is a duplicate edge?
    void addEdge(int source, int destination, int weight) {
        addVertex(source);
        addVertex(destination);

        adjList[source].emplace_back(destination, weight);
    }

    // 移除边
    bool removeEdge(int source, int destination) {
        if (adjList.find(source) == adjList.end()) {
            return false;
        }

        auto &edges = adjList[source];

        for(auto it = edges.begin(); it != edges.end(); ++it){
            if(it->destination == destination) {
                edges.erase(it);
                return true;
            }
        }

        return false;
    }

    // 移除顶点
    void removeVertex(int vertex) {
        if (adjList.find(vertex) == adjList.end()) {
            return ;
        }

        adjList.erase(vertex);

        for(auto& [v, edges]: adjList) {
            edges.remove_if([vertex](const Edge& edge) {
                return edge.destination == vertex;
            });
        }

        numVertices--;
    }

    // 检查边是否存在
    bool hasEdge(int source, int destination) const {
        if (adjList.find(source) == adjList.end()) {
            return false;
        }

        const auto &edges = adjList.at(source);
        for(const auto& edge : edges) {
            if(edge.destination == destination) {
                return true;
            }
        }
        return false;
    }

    // 获取边的权重
    int getEdgeWeight(int source, int destination) const {
        if (adjList.find(source) == adjList.end()) {
            return INT_MAX;
        }

        const auto &edges = adjList.at(source);
        for(const auto& edge : edges) {
            if(edge.destination == destination) {
                return edge.weight;
            }
        }
        return INT_MAX;
    }

    // 获取顶点的所有邻居
    vector<pair<int, int>> getNeighbors(int vertex) const {
        vector<pair<int, int>> neighbors;

        if (adjList.find(vertex) != adjList.end()) {
            const auto& edges = adjList.at(vertex);
            for (const auto& edge : edges) {
                neighbors.emplace_back(edge.destination, edge.weight);
            }
        }

        return neighbors;
    }

    // 获取所有顶点
    vector<int> getAllVertices() const {
        vector<int> vertices;
        for (const auto& pair : adjList) {
            vertices.push_back(pair.first);
        }
        sort(vertices.begin(), vertices.end());
        return vertices;
    }

    // 获取顶点数量
    int getVertexCount() const {
        return adjList.size();
    }

    // 获取边数量
    int getEdgeCount() const {
        int count = 0;
        for (const auto& pair : adjList) {
            count += pair.second.size();
        }
        return count;
    }

    // 深度优先搜索
    vector<int> DFS(int startVertex) const {
        vector<int> result;
        unordered_map<int, bool> visited;

        for(const auto &[source, _] : adjList) {
            visited[source] = false;
        }

        DFSHelper(startVertex, visited, result);

        return result;
    }

    // 广度优先搜索
    vector<int> BFS(int startVertex) const {
        vector<int> result;

        if (adjList.find(startVertex) == adjList.end()) {
            return result;
        }

        queue<int> q;
        unordered_map<int, bool> visited;

        // 初始化所有顶点为未访问
        for (const auto& pair : adjList) {
            visited[pair.first] = false;
        }

        q.push(startVertex);
        visited[startVertex] = true;

        while(!q.empty()) {
            int current = q.front();
            q.pop();
            result.push_back(current);

            if(adjList.find(current) == adjList.end()) {
                continue;
            }

            for(const auto &edge : adjList.at(current)) {
                if (!visited[edge.destination]) {
                    q.push(edge.destination);
                    visited[edge.destination] = true;
                }
            }
        }

        return  result;
    }

    // 打印图
    void printGraph() const {
        cout << "Directed Weighted Graph:\n";
        for (const auto& pair : adjList) {
            cout << "Vertex " << pair.first << ": ";
            for (const auto& edge : pair.second) {
                cout << "(" << edge.destination << ", " << edge.weight << ") ";
            }
            cout << "\n";
        }
    }

private:
    // DFS辅助函数
    void DFSHelper(int vertex,
                   unordered_map<int, bool> &visited,
                   vector<int> &result) const {
        if(adjList.find(vertex) == adjList.end()){
            return;
        }

        visited[vertex] = true;
        result.push_back(vertex);

        for(const auto &edge : adjList.at(vertex)) {
            if (!visited[edge.destination]) {
                DFSHelper(edge.destination, visited, result);
            }
        }
    }
};
```

## 有向加权图 (邻接矩阵实现)

## 有向无权图 (邻接表实现)

- 直接沿用有向加权图的邻接表实现，只需将权重省略或设为默认值（如 1）。

## 有向无权图 (邻接矩阵实现)

- 直接沿用有向加权图的邻接矩阵实现，只需将权重省略或设为默认值（如 1）。

## 无向加权图 (邻接表实现)

- 无向图的邻接表实现与有向图类似，但每条边需要在两个节点的邻接表中都添加一条记录。

## 无向加权图 (邻接矩阵实现)

- 无向图的邻接矩阵实现与有向图类似，但矩阵是对称的，即 matrix[i][j] = matrix[j][i]。

## 无向无权图 (邻接表实现)

- 直接沿用无向加权图的邻接表实现，只需将权重省略或设为默认值（如 1）。

## 无向无权图 (邻接矩阵实现)

- 直接沿用无向加权图的邻接矩阵实现，只需将权重省略或设为默认值（如 1）。
