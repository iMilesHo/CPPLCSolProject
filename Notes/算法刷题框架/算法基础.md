## 静态数组

```
int arr[10];
memset(arr, 0, sizeof(arr)); // 初始化为0，否则为随机值
```

## 动态数组

```cpp
vector<int> arr(10); // 初始化为0
vector<int> arr(10, -1); // 初始化为-1
iota(arr.begin(), arr.end(), 0);  // 初始化为0,1,2,3...
vector<int> arr = {1, 2, 3, 4, 5}; // 初始化为指定值
arr.resize(20); // 改变大小，新增元素初始化为0
arr.push_back(6); // 添加元素
arr.pop_back(); // 删除最后一个元素
arr.clear(); // 清空数组
arr.size(); // 获取大小
arr.empty(); // 判断是否为空
arr[0]; // 访问元素
arr.at(0); // 访问元素，带边界检查
arr.front(); // 获取第一个元素
arr.back(); // 获取最后一个元素
arr.insert(arr.begin() + 2, 10); // 在位置2插入10
arr.erase(arr.begin() + 2); // 删除位置2的元素
arr.erase(arr.begin() + 2, arr.begin() + 4); // 删除位置2到4的元素
arr.swap(other); // 交换两个数组
arr.assign(5, 1); // 重新赋值，变为5个1
arr.assign(other.begin(), other.end()); // 重新赋值为另一个数组的内容
arr.resize(15, -1); // 改变大小，新增元素初始化为-1
arr.reserve(100); // 预留空间，避免频繁扩容
arr.shrink_to_fit(); // 收缩容量到当前大小
```

```cpp
//在遍历的时候删除时，最好使用这个迭代器，因为执行erase操作后，原来的迭代器就失效了
for (auto it = vec.begin(); it != vec.end();) {
    if (shouldDelete(*it)) {
        it = vec.erase(it);  // 返回下一个有效位置
    } else {
        ++it;
    }
}
```

```cpp
auto it1 = find(vec.begin(), vec.end(), 3);
if (it1 != vec.end()) {}

// 找第一个大于4的数
auto it2 = find_if(vec.begin(),
                       vec.end(),
                       [](int x) { return x > 4; });
if (it2 != vec.end()){}

cout << "All positions of 2: ";
auto it3 = vec.begin();
while ((it3 = find(it3, vec.end(), 2)) != vec.end())
{
    cout << (it3 - vec.begin()) << " ";
    ++it3;  // 移动到下一个位置继续查找
}
cout << endl;

int count = std::count(vec.begin(), vec.end(), 2);
itn count = std::count_if(vec.begin(), vec.end(),
                          [](int x) { return x % 2 == 0; });
```

## 遍历数组

```

```
