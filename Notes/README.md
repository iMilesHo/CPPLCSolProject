Below is a structured roadmap of topics commonly tested in technical coding interviews, organized into tiers based on their frequency, foundational importance, and the urgency with which you should master them. This prioritization is a general guideline—individual preferences and company-specific focuses may vary, but it’s a good starting point.

---

### Tier 1 (High Priority & Immediate Focus)

**Why These First?**  
They are the most frequently tested and form the foundation for solving more complex problems. Mastery here will give you a solid base to tackle a wide range of interview questions.

1. **Arrays & Strings**

   - Common operations (iteration, manipulation)
   - Prefix sums, sliding window techniques, two-pointer strategies
   - String pattern searching, substring problems

2. **Hashing & Dictionaries (Maps), Sets**

   - Using hash maps/sets for O(1) look-ups
   - Frequency counting, duplicates detection, and grouping problems

3. **Sorting & Searching**

   - Sorting algorithms and their complexities
   - Binary search on sorted arrays, search patterns

4. **Stacks & Queues**
   - Validating parentheses, next greater element
   - Breadth-first searches (leveraging queues), stack-based problem solving

---

### Tier 2 (Moderate Priority & Next Steps)

**Why These Next?**  
These structures and techniques appear often, sometimes as part of more complex problems. They build upon your Tier 1 understanding.

1. **Linked Lists**

   - Reversal of lists, cycle detection, merging and splitting lists

2. **Trees**

   - Binary tree traversal (in-order, pre-order, post-order)
   - Binary Search Tree operations (insertion, deletion, search)
   - Common tree problems like finding height, diameter, lowest common ancestor

3. **Graphs**

   - Basics: Graph representations (adjacency list/matrix)
   - Traversal: Breadth-first search (BFS), Depth-first search (DFS)
   - Fundamental graph problems (connected components, cycle detection)

4. **Recursion & Backtracking**

   - DFS-based solutions for subsets, permutations, combinations
   - Constraint satisfaction problems (e.g., N-Queens, Sudoku solver)

5. **Greedy Algorithms**

   - Interval scheduling, activity selection
   - Common greedy patterns (choosing minimum/maximum first, sorting by a criterion)

6. **Intervals & Sweep Line Techniques**

   - Merging intervals, checking overlaps, interval scheduling

7. **Heaps / Priority Queues**
   - Finding kth smallest/largest element
   - Merging multiple sorted lists, scheduling tasks by priority

---

### Tier 3 (Advanced Concepts)

**Why These Later?**  
These topics are often tested for more senior roles or top-tier companies. While mastery can distinguish you, you won’t encounter them in every interview.

1. **Dynamic Programming (DP)**

   - Classic patterns: Knapsack, Fibonacci variants, grid-based DP
   - Understanding subproblems, memoization, and tabulation

2. **Advanced Graph Concepts**

   - Topological sort
   - Union-Find/Disjoint Set for cycle detection in undirected graphs
   - Shortest paths (Dijkstra, Bellman-Ford) if relevant

3. **Tries (Prefix Trees)**

   - Word search, autocomplete features
   - Efficient prefix queries on strings

4. **Segment Trees & Binary Indexed Trees (Fenwick Trees)**

   - Range queries (range sum, range minimum/maximum)
   - Updating elements and querying results in O(log n)

5. **Bit Manipulation**
   - Basic operations, common tricks (parity check, bit masks)

---

### Tier 4 (Nice-to-Have / Advanced Rounds)

**Why These Last?**  
They are either less commonly tested in standard coding interviews or more relevant to system design or highly specialized roles.

1. **Advanced Data Structures**

   - Balanced Trees (AVL, Red-Black Trees) – rarely required explicitly, but conceptually helpful

2. **System Design Concepts**
   - While not a data structure/algorithm per se, understanding the scalability of solutions and some high-level architectures can be beneficial in later-stage interviews.

---

**Final Advice**:

- **Master Tier 1 first**, as these fundamentals repeat in many problems.
- **Progress to Tier 2** to build breadth.
- **If time allows**, delve into Tier 3 and Tier 4 to gain a competitive edge.

By following this structured progression, you ensure you’re covering the most critical and common topics first, then broadening your skill set to stand out in more challenging interviews.

---

** Top 150 LeetCode Problems (by frequency) **
=== Array / String ===
Total questions: 24
Difficulty: {'EASY': 9, 'MEDIUM': 12, 'HARD': 3}
Top Tags:

- Array: 17
- Two Pointers: 8
- String: 8
- Dynamic Programming: 5
- Greedy: 5
- Hash Table: 4
- Math: 4
- Sorting: 3
- Divide and Conquer: 1
- Counting: 1
- Counting Sort: 1
- Design: 1
- Randomized: 1
- Prefix Sum: 1
- Stack: 1
- Monotonic Stack: 1
- Trie: 1
- String Matching: 1
- Simulation: 1

=== Two Pointers ===
Total questions: 5
Difficulty: {'EASY': 2, 'MEDIUM': 3, 'HARD': 0}
Top Tags:

- Two Pointers: 5
- Array: 3
- String: 2
- Dynamic Programming: 1
- Binary Search: 1
- Greedy: 1
- Sorting: 1

=== Sliding Window ===
Total questions: 4
Difficulty: {'EASY': 0, 'MEDIUM': 2, 'HARD': 2}
Top Tags:

- Sliding Window: 4
- Hash Table: 3
- String: 3
- Array: 1
- Binary Search: 1
- Prefix Sum: 1

=== Matrix ===
Total questions: 5
Difficulty: {'EASY': 0, 'MEDIUM': 5, 'HARD': 0}
Top Tags:

- Array: 5
- Matrix: 5
- Hash Table: 2
- Simulation: 2
- Math: 1

=== Hashmap ===
Total questions: 9
Difficulty: {'EASY': 7, 'MEDIUM': 2, 'HARD': 0}
Top Tags:

- Hash Table: 9
- String: 5
- Array: 4
- Sorting: 2
- Counting: 1
- Math: 1
- Two Pointers: 1
- Sliding Window: 1
- Union Find: 1

=== Intervals ===
Total questions: 4
Difficulty: {'EASY': 1, 'MEDIUM': 3, 'HARD': 0}
Top Tags:

- Array: 4
- Sorting: 2
- Greedy: 1

=== Stack ===
Total questions: 5
Difficulty: {'EASY': 1, 'MEDIUM': 3, 'HARD': 1}
Top Tags:

- Stack: 5
- String: 3
- Math: 2
- Design: 1
- Array: 1
- Recursion: 1

=== Linked List ===
Total questions: 11
Difficulty: {'EASY': 2, 'MEDIUM': 8, 'HARD': 1}
Top Tags:

- Linked List: 11
- Two Pointers: 5
- Hash Table: 3
- Recursion: 3
- Math: 1
- Design: 1
- Doubly-Linked List: 1

=== Binary Tree General ===
Total questions: 14
Difficulty: {'EASY': 6, 'MEDIUM': 7, 'HARD': 1}
Top Tags:

- Tree: 14
- Binary Tree: 14
- Depth-First Search: 10
- Breadth-First Search: 6
- Array: 2
- Hash Table: 2
- Divide and Conquer: 2
- Linked List: 2
- Stack: 2
- Dynamic Programming: 1
- Design: 1
- Binary Search Tree: 1
- Iterator: 1
- Binary Search: 1
- Bit Manipulation: 1

=== Binary Tree BFS ===
Total questions: 4
Difficulty: {'EASY': 1, 'MEDIUM': 3, 'HARD': 0}
Top Tags:

- Tree: 4
- Breadth-First Search: 4
- Binary Tree: 4
- Depth-First Search: 2

=== Binary Search Tree ===
Total questions: 3
Difficulty: {'EASY': 1, 'MEDIUM': 2, 'HARD': 0}
Top Tags:

- Tree: 3
- Depth-First Search: 3
- Binary Search Tree: 3
- Binary Tree: 3
- Breadth-First Search: 1

=== Graph General ===
Total questions: 6
Difficulty: {'EASY': 0, 'MEDIUM': 6, 'HARD': 0}
Top Tags:

- Depth-First Search: 6
- Breadth-First Search: 6
- Graph: 4
- Array: 3
- Union Find: 3
- Matrix: 2
- Topological Sort: 2
- Hash Table: 1
- String: 1
- Shortest Path: 1

=== Graph BFS ===
Total questions: 3
Difficulty: {'EASY': 0, 'MEDIUM': 2, 'HARD': 1}
Top Tags:

- Breadth-First Search: 3
- Hash Table: 2
- String: 2
- Array: 1
- Matrix: 1

=== Trie ===
Total questions: 3
Difficulty: {'EASY': 0, 'MEDIUM': 2, 'HARD': 1}
Top Tags:

- String: 3
- Trie: 3
- Design: 2
- Hash Table: 1
- Depth-First Search: 1
- Array: 1
- Backtracking: 1
- Matrix: 1

=== Backtracking ===
Total questions: 7
Difficulty: {'EASY': 0, 'MEDIUM': 6, 'HARD': 1}
Top Tags:

- Backtracking: 7
- String: 3
- Array: 3
- Hash Table: 1
- Dynamic Programming: 1
- Depth-First Search: 1
- Matrix: 1

=== Divide & Conquer ===
Total questions: 4
Difficulty: {'EASY': 1, 'MEDIUM': 2, 'HARD': 1}
Top Tags:

- Divide and Conquer: 4
- Array: 2
- Tree: 2
- Linked List: 2
- Merge Sort: 2
- Binary Search Tree: 1
- Binary Tree: 1
- Two Pointers: 1
- Sorting: 1
- Matrix: 1
- Heap (Priority Queue): 1

=== Kadane's Algorithm ===
Total questions: 2
Difficulty: {'EASY': 0, 'MEDIUM': 2, 'HARD': 0}
Top Tags:

- Array: 2
- Divide and Conquer: 2
- Dynamic Programming: 2
- Queue: 1
- Monotonic Queue: 1

=== Binary Search ===
Total questions: 7
Difficulty: {'EASY': 1, 'MEDIUM': 5, 'HARD': 1}
Top Tags:

- Array: 7
- Binary Search: 7
- Matrix: 1
- Divide and Conquer: 1

=== Heap ===
Total questions: 4
Difficulty: {'EASY': 0, 'MEDIUM': 2, 'HARD': 2}
Top Tags:

- Heap (Priority Queue): 4
- Array: 3
- Sorting: 3
- Divide and Conquer: 1
- Quickselect: 1
- Greedy: 1
- Two Pointers: 1
- Design: 1
- Data Stream: 1

=== Bit Manipulation ===
Total questions: 6
Difficulty: {'EASY': 4, 'MEDIUM': 2, 'HARD': 0}
Top Tags:

- Bit Manipulation: 6
- Divide and Conquer: 2
- Array: 2
- Math: 1
- String: 1
- Simulation: 1

=== Math ===
Total questions: 6
Difficulty: {'EASY': 3, 'MEDIUM': 2, 'HARD': 1}
Top Tags:

- Math: 6
- Array: 2
- Binary Search: 1
- Recursion: 1
- Hash Table: 1
- Geometry: 1

=== 1D DP ===
Total questions: 5
Difficulty: {'EASY': 1, 'MEDIUM': 4, 'HARD': 0}
Top Tags:

- Dynamic Programming: 5
- Array: 4
- Memoization: 2
- Math: 1
- Hash Table: 1
- String: 1
- Trie: 1
- Breadth-First Search: 1
- Binary Search: 1

=== Multidimensional DP ===
Total questions: 9
Difficulty: {'EASY': 0, 'MEDIUM': 7, 'HARD': 2}
Top Tags:

- Dynamic Programming: 9
- Array: 6
- Matrix: 3
- String: 3
- Two Pointers: 1
