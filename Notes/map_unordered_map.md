## `std::map` vs `std::unordered_map`

| 特性           | `std::map`  | `std::unordered_map`     |
| -------------- | ----------- | ------------------------ |
| 底层结构       | 红黑树      | 哈希表                   |
| 元素顺序       | 按 key 排序 | 无序                     |
| 查找/插入/删除 | `O(log n)`  | 平均 `O(1)`，最坏 `O(n)` |
| 遍历顺序       | 有序        | 无序                     |
| 内存使用       | 较少        | 较多                     |

## red-black tree

## 1. 什么是红黑树

红黑树是一种 **自平衡二叉搜索树（BST）**。
它保证了树的高度始终是 `O(log n)`，从而使得查找、插入和删除操作都能在 `O(log n)` 的时间复杂度内完成。

### 红黑树的 5 条性质

红黑树是一种 **带颜色标记的自平衡二叉搜索树（BST）**，它在 BST 的基础上增加了颜色规则，使得树的高度被严格控制。

1. **每个节点要么是红色，要么是黑色。**
   → 二元状态，为后续规则提供限制条件。

2. **根节点一定是黑色。**
   → 保证从根出发的路径都有统一的黑色起点。

3. **所有叶子节点（NIL 空节点）都是黑色。**
   → 技术细节，让所有路径定义更清晰。

4. **红色节点的子节点必须是黑色（不能有两个连续的红节点）。**
   → 保证树不会出现长长的“红链条”，避免过度倾斜。

5. **从任意一个节点出发，到达所有叶子节点的路径上，黑色节点的数量相同（黑高一致）。**
   → 保证了树的“近似平衡”。

> 这些规则保证了树的“接近平衡”。虽然不保证完全平衡，但能保证最长路径不会超过最短路径的 2 倍。

---

## 2. 为什么 `std::map` 用红黑树

- **有序性：** 红黑树是 BST，所以天然支持有序遍历（中序遍历）。
- **稳定性能：** 查找/插入/删除都是 `O(log n)`，不会像哈希表那样最坏情况退化为 `O(n)`。
- **标准要求：** C++ 标准规定 `std::map` 是 _logarithmic complexity_，红黑树是经典实现。

---

## 3. 学习路线建议

你并 **不一定非要完整实现一个红黑树** 才能理解 `std::map`，但自己实现一遍能加深理解。
推荐分 3 步走：

1. **掌握普通二叉搜索树（BST）**

   - 会写基本的插入、查找、删除。
   - 理解什么情况下 BST 会退化（比如插入有序数据 → 变成链表）。

2. **学习“自平衡”的思想**

   - 先看 AVL 树（比红黑树容易理解，但不如红黑树常用）。
   - 再看红黑树的“旋转操作”（左旋、右旋）。

3. **实现一个简化版的红黑树**

   - 可以只实现插入和查找（删除更复杂）。
   - 重点是理解：**通过颜色 + 旋转保持平衡**。

---

## 4. 面试/工程角度

- 面试时，通常不会要求你从零写一个红黑树。
- 更常见的是：

  - 知道 `std::map` 和 `std::unordered_map` 的底层实现和复杂度。
  - 能解释为什么 `map` 遍历是有序的。
  - 能画出旋转示意图，说明红黑树如何保持平衡。

所以：
👉 如果目标是理解 `std::map`，你需要 **会讲红黑树的性质 + 会解释为什么操作是 O(log n)**。
👉 如果想深入数据结构功底，可以尝试自己写一个红黑树（练手项目，帮助很大）。

---

## 5. 总结一句话

红黑树是 `std::map` 的底层，它保证了有序性和 `O(log n)` 的性能。
学习时不必强行从零实现，但理解它的性质和“颜色 + 旋转”的平衡机制非常重要。

## 为什么操作是 O(log n)

### 先看 BST 的问题

普通的二叉搜索树（BST）：

- 插入时只根据大小放左边或右边。
- 如果插入的序列是有序的，比如 `[1,2,3,4,5]`，树会退化成链表，树高变成 `O(n)`。
- 这样查找/插入就会变成 `O(n)`，性能失控。

---

### 红黑树的平衡性保证

红黑树通过“颜色规则 + 旋转”来维持平衡。关键在于 **性质 5**：

- 如果树有 `n` 个节点，黑高 = `h`。
- 最短路径 = `h`（全是黑节点）。
- 最长路径 ≤ `2h`（红黑交替）。
- 因为树的黑高 ≈ `log n`，所以最长路径也就是 `O(log n)`。

> **结论**：树的高度始终是 `O(log n)`，查找/插入/删除都不会退化。

---

### 插入/删除如何保持平衡？

当插入或删除导致某个规则被破坏时（比如出现两个连续的红节点）：

- 红黑树通过 **旋转（左旋/右旋）+ 重新染色** 来恢复规则。
- 旋转是常数操作，不会影响整体复杂度。
- 调整的次数也有限，不会超过 `O(log n)` 层。

所以：

- **查找**：最多走树高 → `O(log n)`。
- **插入/删除**：做一次 BST 操作（`O(log n)`），再通过有限次旋转/染色恢复 → 仍然 `O(log n)`。

---

## 3. 你在面试里可以这么讲（简洁版）：

> 红黑树是一种带颜色标记的自平衡二叉搜索树。它有 5 条规则：根是黑的、叶子是黑的、红色不能连着红色、每条路径黑色数相等、节点非黑即红。
> 这些规则保证了树的高度最多是最短路径的两倍，因此树高始终是 `O(log n)`。查找需要走树高，插入和删除可能会破坏规则，但通过旋转和染色修复，仍然只需要 `O(log n)`。
> 所以红黑树能保证所有操作都在 `O(log n)`，这就是 `std::map` 的底层实现。
