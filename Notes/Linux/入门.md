1.内存映射的原理（memory mapping）

将一块内存空间映射到不同的进程空间中

2.define 和 const 的区别

1.define 是预处理指令，用于创建符号常量。const 是 C 和 C++的关键字，用于创建具有常量值的变量，本质是只读变量。

2.define 在预处理阶段执行。const 在编译阶段执行。

3.define 没有类型检查，仅进行文本替换。const 有类型检查，可以与变量类型关联。

3.数组和链表的区别

1.数组内存连续，链表内存不连续。

2.数组访问速度比链表快

3.链表增加删除操作比数组快

4.指针和引用的区别

1.指针：指针是一个变量，保存着内存地址。引用：引用是已存在变量的别名，没有自己的内存地址。

2.指针可以具有空值(NULL)，引用不能为空，必须在初始化时指向一个有效的对象。

3.可以修改指针的指向，可以将指针重新赋值为另一个地址。一旦引用被初始化，它始终指向同一个对象，不可更改。

4.指针需要额外的内存空间来存储地址值。引用不需要额外的内存空间，因为它是对已存在变量的别名。

5.解释一下 QT 的信号与槽

信号与槽是一种用于实现对象之间通信和事件处理的机制。

6.IIC 为什么要加上拉电阻，为什么使用开漏输出

上拉电阻

1.当 IIC 总线在空闲状态，SDA 和 SCL 需要处于高电平状态。

2.开漏输出无法输出高电平，使用上拉电阻可以完成高低电平之间的转换。

开漏输出

1.假如使用推挽输出可能导致器件的烧毁

2.实现线与功能

7.MQTT 的通信过程

1.创建客户端

2.指定 IP 地址和端口号

3.进行连接

4.发布主题或者订阅主题

5.数据传输

6.断开连接

8.在 Linux 中怎么实现同步

1.互斥锁

2.信号量

3.条件变量

9.TCP 和 UDP 的应用场景

1.TCP：文件传输、电子邮件、网页浏览。

2.UDP：实时音视频传输、在线游戏、实时监控。

10.什么是野指针，什么情况会产生野指针

什么是野指针

1.指向已被释放或无效的内存地址的指针是野指针。

什么情况下产生野指针

1.内存释放后未置空指针

int*ptr=(int*)malloc(sizeof(int));free(ptr);\*ptr=10;//这里 ptr 成为了野指针

2.返回局部变量的指针

int*getIntPointer(){
intnum=5;
return#//返回局部变量的指针
}
int*ptr=getIntPointer();
\*ptr=10;//getIntPointer 返回一个野指针 3.未初始化指针

char\*p;

11.什么是互斥锁

互斥锁是一种用于线程同步的机制，用于确保同一时间只有一个线程访问共享资源。

12.数组和指针的区别

数组是一块连续的内存空间，其大小在编译时确定，访问元素使用下标操作；而指针是一个变量，存储地址值，大小固定，可以指向不同类型的数据，通过解引用操作访问内存中的数据。

13.如何防止重复引用头文件

1.使用预处理指令

#ifndefHEADER_FILE_NAME_H

#defineHEADER_FILE_NAME_H

//头文件内容

#endif//HEADER_FILE_NAME_H

2.使用#pragmaonce

14.栈和队列的区别

1.栈是后进先出的数据结构，而队列是先进先出的数据结构。

2.栈常用于表达式求值、函数调用的调用栈、括号匹配等需要后进先出的场景。队列常用于任务调度、缓冲区管理、消息传递等需要先进先出的场景。

15.为什么中断不能传递参数

中断是异步调用，无法知道什么时候会被调用，不能够像函数一样主动调用。

16.串口数据帧格式

起始位，数据位，校验位，停止位。

17.中断的概念

中断是计算机系统中一种重要的处理机制，用于响应某种事件或条件的发生。它是一种异步的事件，可以打断当前正在执行的程序或任务，以处理紧急情况或外部设备的请求。

18.static 的作用

控制变量生命周期，控制作用域，控制文件可见性。

19.中断的执行过程

中断的执行过程包括中断请求、中断控制器响应、中断响应、中断向量确定、中断处理程序执行和中断处理程序结束。

20.什么是多态

多态是面向对象编程中的一种特性，它允许以一种统一的方式处理不同类型的对象，通过相同的接口可以表现出不同的行为。

21.C 语言中的内存分配方式有几种

1.静态内存分配。

2.栈上内存分配。

3.堆上内存分配。

22.struct 和 class 的区别

1.默认访问权限不同，struct 的默认访问权限是 public，class 的默认访问权限是 private。

2.继承方式不同，struct 的默认继承方式是公有继承，class 的继承访问是私有继承。

3.在一般情况下，struct 被用于表示数据结构，而 class 则更多用于表示具有行为和数据的对象。

23.函数和中断的区别

1.函数调用不会发生上下文切换，中断调用会发生上下文切换。

2.函数可以主动被调用，中断无法主动被调用。

3.函数调用是同步的，中断是异步的。

4.函数可以有返回值和参数，中断没有返回值和参数。

24.自旋锁和信号量的区别

自旋锁是一种忙等待的方式，适用于临界区执行时间短暂、锁冲突概率低的情况；而信号量是一种阻塞机制，适用于临界区执行时间长、锁冲突概率高的情况，自旋锁不会进入休眠，信号量会进入休眠。

25.怎么判断链表是否有环

使用快慢指针。

思路：

创建两个指针，一个指针称为快指针（fast），另一个指针称为慢指针（slow），初始时都指向链表的头节点。

快指针每次向前移动两个节点，慢指针每次向前移动一个节点。

如果链表中存在环，那么快指针和慢指针最终会相遇。

如果链表中不存在环，那么快指针最终会先到达链表尾部，此时可以判断链表无环。

26.使用多线程时需要注意什么

线程安全：多线程环境下，多个线程同时访问共享资源可能会引发竞态条件（RaceCondition），导致数据不一致或其他异常情况。确保共享资源的访问是线程安全的，可以通过使用互斥锁（Mutex）、条件变量（ConditionVariable）等同步机制来保护共享资源的访问。

线程间通信：在多线程编程中，不同线程之间可能需要进行通信和协作。合理地设计和使用线程间通信机制，如队列（Queue）、信号量（Semaphore）、事件（Event）等，可以有效地实现线程之间的同步和传递信息。

死锁：死锁是指两个或多个线程在互相等待对方释放资源而无法继续执行的状态。避免死锁的方法之一是按照固定的顺序获取锁，避免循环依赖。另外，可以使用资源分配图等方法进行死锁检测和预防。

上下文切换开销：线程切换需要保存当前线程的上下文并加载下一个线程的上下文，这涉及到时间和空间的开销。在设计多线程应用程序时，需要注意减少线程切换的频率，避免过度创建线程和过度频繁地切换线程，以提高程序性能。

共享资源的合理使用：多线程环境下，共享资源可能被多个线程同时访问，需要注意共享资源的正确使用和保护。避免线程之间的竞争和冲突，需要考虑线程安全性，使用适当的同步机制对共享资源进行保护。

有效的线程调度和任务划分：在多线程编程中，线程的调度和任务的划分对系统性能和响应能力有重要影响。合理规划线程数量和调度策略，均衡地分配任务，避免线程之间的争抢和饥饿现象，以提高系统整体的吞吐量和响应性能。

错误处理和异常处理：在多线程环境下，错误和异常的处理需要更加谨慎。及时捕获和处理线程中的异常，确保程序的稳定性和可靠性。

27.实现 strcpy 函数

char*mystrcpy(char*str,constchar*str1)
{
char*temp=str;
while(*temp++=*str1++);
returnstr;
}

28.实现 strcat 函数

char*mystrcat(char*str1,char*str2)
{
char*temp=str1;
while(*temp!='\0')
{
temp++;
}
while(*str2!='\0')
{
*temp=*str2;
temp++;
str2++;
}
\*temp='\0';
returnstr1;
}
